![](https://itlab1024-1256529903.cos.ap-beijing.myqcloud.com/202207281322806.png)

# Go整型

## 整型分类

Go中整型和起来语言类似，主要分为有符号和无符号，对于有符号整数，最高位为符号位。

* 有符号整数主要包含如下具体类型
  1. int8 (8位有符号整数，范围是-128 到 127)
  2. int16  (16位有符号整数， 范围是-32768 到 32767
  3. int32 (32位有符号整数，范围是 -2147483648 to 2147483647)
  4. int64 (64位有符号整数，范围是-9223372036854775808 to 9223372036854775807)
* 无符号整数主要包含如下具体类型
  1. uint8 (8位无符号整数，范围是 0到 255)
  2. uint16  (16位无符号整数， 范围是0 到 65535
  3. uint32 (32位无符号整数，范围是 0 到 4294967295)
  4. uint64 (64位无符号整数，范围是 0 到 18446744073709551615)

其实在go中对于有符号和无符号类型，还有int和uint类型，其实这是简写，分别代表int32和uint32。

## 问题

很多人可能会想这个范围是如何计算的？我这里简单说明下，8位有符号和无符号来解释下。



有符号：

1. int8占1个字节(byte) 也就是8个二进制位(bit)
2. 每个二进制位 可以存储0 和 1 两个数 ，8个二进制位就有2^8 = 256种组合(可以存储256个数)
3. int8为有符号，所以正数和负数将平分256个数。256 / 2 = 128
4. 负数为128个数 最小值为-128 
5. 正数为128个数，0占一个数 最大值为+127

无符号：

uint8(8bit无符号-没有负数) 2^8 = 256 0 占一个数 ，所以最大是255。

如果了解计算机中数字的原码、反码、补码就会更容易理解。我这里就不细说了。

## 溢出

使用更大范围的数初始化一个能接受小范围的类型的变量，这是不允许的。编译不通过，比如如下代码。

```go
package main

func main() {
	// 大范围赋值给小范围类型。
	var i int8 = 128 // 编译错误 ，因为int8的范围是（-127-127）
}
```

有的时候编辑器并不知道是否移除，比如运算的时候。

```go
package main

func main() {
	// 大范围赋值给小范围类型。
	//var i int8 = 128 // 编译错误 ，因为int8的范围是（-127-127）
	var j int8 = 127
	var k int8 = j + 1
	println(k) // 结果溢出，并不是128，而是-128
}

```

我们来解释下。

计算是通过补码来计算的。

需要注意的是。正数的反码和补码与原码相同，负数的反码是对其原码逐位取反,但符号位除外;负数的补码是在其反码的末位加1.所以负数的原码、补码、反码不相同。

127的原码是 0111 1111，他的反码和补码也是0111 1111。加1后就变为了1000 0000，这就是-128。

## 类型转换

每种类型都有一个对应的同名的方法用于类型转换

```go
package main

func main() {
	// 大范围赋值给小范围类型。
	//var i int8 = 128 // 编译错误 ，因为int8的范围是（-127-127）
	var j int8 = 127
	var k int8 = j + 1
	println(k) // 结果溢出，并不是128，而是-128

	// 类型转换
	var l int32 = int32(k)
	println(l)
}
```

上面就是将int8类型的数字通过int32()方法转化为了int32类型。